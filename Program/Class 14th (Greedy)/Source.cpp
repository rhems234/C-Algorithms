#include <iostream>

using namespace std;

int main()
{
#pragma region 탐욕법
	// 최적의 해를 구하는 데에 사용되는 근사적인 방법으로 여러 경우 중
	// 하나를 검색해야 할 때 마다 그 순간에 최적이라고 생각되는 것을 선택해
	// 나가는 방식으로 진행하여 최종적인 해답을 구하는 알고리즘입니다.

	// 1. 탐욕 선택 속성
	// 각 단게에서 '최적의 선택'을 했을 때 전체 문제에 대한
	// 최적의 해를 구할 수 있는 경우입니다.

	// 2. 최적 부분 구조
	// 전체 문제의 최적의 해가 '부분 문제의 최적의 해로 구성'될
	// 수 있는 경우입니다.

	// 탐욕 알고리즘으로 문제를 해결하는 방법

	// 1. 선택 절차 ( Selection Progcedure )
	// 현재 상태에서의 최적의 해답을 선택합니다.

	// 거스름돈의 동전 개수를 줄이기 위해 가장 가치가 높은 동전을 우선 선택합니다.

	// 2. 적절성 검사 ( Feasibility Check )
	// 선택된 해가 문제의 조건을 만족하는 지 검사합니다.

	// 1번 과정을 통해 선택된 동전들의 합이 거슬러 줄 금액을 초과하는 지 검사합니다.
	// 초과한다면 가장 마지막에 선택한 동전을 삭제하고, 1번으로 돌아가 한 단계 작은
	// 동전을 선택합니다.

	// 3. 해답 검사 ( Solution Check )
	// 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면
	// 선택 절차로 돌아가 위의 과정을 반복합니다.

	// 선택된 동전들의 합이 거슬러 줄 금액과 일치하는지 검사합니다.
	// 액수가 부족하면 1번 과정부터 다시 반복합니다.

	int n = 1370;

	/*int coin[5] = { 1000, 500, 100, 50, 10 };
	int count = 0;

	for (int i = 0; i < 5; i++)
	{
		count += n / coin[i];
		n = n % coin[i];
	}

	cout << "total : " << count << endl;*/

	int count = 0;

	while (n >= 10)
	{
		if (n >= 1000)
		{
			n -= 1000;
		}
		else if (n >= 500)
		{
			n -= 500;
		}
		else if (n >= 100)
		{
			n -= 100;
		}
		else if (n >= 50)
		{
			n -= 50;
		}
		else if (n >= 10)
		{
			n -= 10;
		}
		count++;
	}

	cout << "count : " << count << endl;

#pragma endregion


	return 0;
}